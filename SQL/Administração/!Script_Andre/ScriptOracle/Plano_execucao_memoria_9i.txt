Generate Execution Plans Directly from the Library Cache
Compliments of Garry Robinson, OracleAdvice 

The introduction of Oracle9i brought with it the capability to 
view execution plan information for all parsed cursors stored 
in the library cache. This information is exposed through the 
view V$SQL_PLAN and is fairly similar in format to the well 
known PLAN_TABLE, which is used by diagnostic tools such as 
tkprof and SQL*Plus autotrace. PLAN_TABLE is created by running 
the script $ORACLE_HOME/rdbms/admin/utlxplan.sql 
The problem with using tkprof and autotrace has always been 
that they generate the execution plan at the point in time 
that they are run. Up until now, there has never been a way 
to retrospectively generate an execution plan for the point
 in time that the SQL was originally parsed. This was fine 
in the days of the rule-based optimizer when plans were generated
 by following an ordered set of rules (and were therefore predictable
 and consistent). Nowadays, most databases are configured to use 
the cost-based optimizer, so Oracle must rely on statistics in the
 data dictionary being up to date. Out of date statistics can 
lead to Oracle generating sub-optimal execution plans so it is 
important to know the execution plan that Oracle chose at the 
time the statement was parsed when performance tuning slow-running SQL statements. 

To improve the display of execution plans, Oracle provides
 a neat PL/SQL table function packaged as DBMS_XPLAN.DISPLAY. 

It takes in 3 arguments: the table_name, which must be a table
 matching the format of the traditional PLAN_TABLE, an identifier
for the SQL statement, and a format which can be Basic, Typical, 
All or Serial. Typical is the default and will show optimizer information 
specific to the execution plan such as partition elimination and parallelism. 

It is invoked as follows: 
SELECT * FROM table(DBMS_XPLAN.DISPLAY('plan_table', '&1', 'TYPICAL'));

Unfortunately, the format of V$SQL_PLAN does not quite match the format o
f PLAN_TABLE. This effectively means that these 2 great features cannot easily 
be used together. In fact, if you try to use V$SQL_PLAN in place of a proper
 PLAN_TABLE then you get an error: 
ORA-00904: "STATEMENT_ID": invalid identifier
I think that this is a shame so I came up with a way of getting the best of
 both worlds. First, get the address of the parsed SQL statement that you are
interested in tuning, for example: 
SQL> select sql_text, address from v$sql …

SQL_TEXT                                                     ADDRESS 
------------------------------------------------------------ ----------------
select q1."PRIMARY_ACCOUNT_ID", q1."TRANSACTION_CODE", q1    00000003977292C0

Using the address as an identifier, extract the execution plan 
information from V$SQL_PLAN and reformat it by inserting into 
a conventional PLAN_TABLE. Then invoke the PL/SQL table function 
to display a formatted execution plan for the SQL. The rollback 
just clears out the rows from PLAN_TABLE. 

<<<<save this as plan.sql>>>>
insert into plan_table
select
 ADDRESS,
 sysdate,
 'REMARKS',
 OPERATION,
 OPTIONS,
 OBJECT_NODE,
 OBJECT_OWNER,
 OBJECT_NAME,
 0,
 'OBJECT_TYPE',
 OPTIMIZER,
 SEARCH_COLUMNS,
 ID,
 PARENT_ID,
 POSITION,
 COST,
 CARDINALITY,
 BYTES,
 OTHER_TAG,
 PARTITION_START,
 PARTITION_STOP,
 PARTITION_ID,
 OTHER,
 DISTRIBUTION,
 CPU_COST,
 IO_COST,
 TEMP_SPACE,
 ACCESS_PREDICATES,
 FILTER_PREDICATES
from
 v$sql_plan
where
  address = '&1';


SELECT * FROM table(DBMS_XPLAN.DISPLAY('plan_table', '&1'));

rollback;
<<<<cut here>>>>

SQL> @plan 00000003977292C0
old 33: where address = '&1'
new 33: where address = '00000003977292C0'

6 rows created.

old 1: SELECT * FROM table(DBMS_XPLAN.DISPLAY('plan_table', '&1'))
new 1: SELECT * FROM table(DBMS_XPLAN.DISPLAY('plan_table', '00000003977292C0'))

PLAN_TABLE_OUTPUT
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
| Id  | Operation                            | Name                   | Rows 
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |                        | 
|   1 |  SORT ORDER BY                       |                        | 1 
|*  2 |   FILTER                             |                        | 
|   3 |    PARTITION RANGE ITERATOR          |                        | 
|   4 |     TABLE ACCESS BY LOCAL INDEX ROWID| CARD_TRANSACTION       | 1 
|*  5 |      INDEX RANGE SCAN                | CARD_TRANSACTION_AK1   | 1633K
-----------------------------------------------------------------------------
--(the output has been truncated for display formatting purposes)


Predicate Information (identified by operation id):
--------------------------------------------------- 

2 - filter(:2<=:3)
5 - access("TRANSACTION_DATE">=:2 
    AND "PRIMARY_ACCOUNT_ID"=:1 
    AND "TRANSACTION_DATE"<=:3)
filter("PRIMARY_ACCOUNT_ID"=:1)

Note: cpu costing is off

20 rows selected.


Rollback complete.
If you get an error like: 
Error: cannot fetch plan for statement_id '0000000397739140'
then it probably means that the parameter shared_pool_size has been set too low. 
At the time of writing (9.2.0.3), there are 3 bugs in V$SQL_PLAN that can cause ORA-07445 errors. The bugs are reported to be fixed in 9.2.0.4 but they can be easily worked around. Click here for details. 
