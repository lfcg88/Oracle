On a recent project we had a problem where performance would start acceptable at the beginning of the day and by mid-day would be totally unacceptable. Investigation showed that the third party application that ran on top of the Oracle 7.2.3 database was generating ad hoc SQL with out using bind variables. This generation of ad hoc SQL and non-use of bind variables was resulting in proliferation of non-reusable code fragments in the shared pool, one user had over 90 shared pool segments assigned for queries that differed only by the selection parameter (for example "where last_name='SMITH'" instead of "where last_name='JONES'"). This proliferation of multiple nearly identical SQL statements meant that for each query issued the time to scan the shared pool for identical statements was increasing for each non-reusable statement generated. 

A purely empirical performance test ( the one used by the Q diagnostic tool from Savant, Corporation) showed a performance indicator of 600+ when 30-40 concurrent users where using the system. This corresponded to a query time for a simple select taking nearly 30 seconds. A flush of the shared pool resulting in a more than three-fold drop in the performance indicator to around 150 and the 30 second query returned in less than a second. 

It was determined that an automatic procedure was needed to monitor the shared pool and flush it when it reached 60-70% of capacity. The following procedure was created: 

create or replace view sql_summary as select username, 
   sharable_mem, persistent_mem, runtime_mem
from sys.v_$sqlarea a, dba_users b
where a.parsing_user_id = b.user_id;

create or replace procedure flush_it as
cursor get_share is
 select sum(sharable_mem) from
  system.sql_summary;
cursor get_var is
 select value from v$sga where name like 'Var%';
cursor get_time is 
 select sysdate from dual;
  todays_date date;
  mem_ratio number;
share_mem number;
variable_mem number;
cur integer;
sql_com varchar2(60);
row_proc number;
begin
 open get_share;
 open get_var;
 fetch get_share into share_mem;
dbms_output.put_line('share_mem: '||to_char(share_mem));
 fetch get_var into variable_mem;
dbms_output.put_line('variable_mem: '||to_char(variable_mem));
 mem_ratio:=share_mem/variable_mem;
dbms_output.put_line(to_char(mem_ratio));
 if mem_ratio>0.3 Then
  cur:=dbms_sql.open_cursor;
  sql_com:='alter system flush shared_pool';
  dbms_sql.parse(cur,sql_com,dbms_sql.v7);
  row_proc:=dbms_sql.execute(cur);
  dbms_sql.close_cursor(cur);
  end if;
end;
This procedure was then loaded into the job queue and scheduled to run every hour using the following commands: 
variable x number;
execute dbms_job.submit(x,'flush_it;',sysdate,'sysdate+1/24');
Since instituting the automated flush our performance indicator has never peaked above 250 and rarely varies above 200 event with 90+ concurrent users  