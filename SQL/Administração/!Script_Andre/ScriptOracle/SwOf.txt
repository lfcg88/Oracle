set echo on
set fedd on


set linesize 90
--------------------------------------------------------------------


spool c:\ramos\wait.txt

col event    format a40       heading "Session Wait Event" trunc
col cnt      format 9999      heading "Ocurrs"
col sec      format 999,999,990      heading "Secs In|Wait (sec)"
col dte      format a8          heading "Date"
col key      format 9999         heading "OSM|Key"


select event,
       -- a.key key,
       -- to_char(a.the_date,'DD HH24:MI') dte,
       sum(seconds_in_wait) sec,
       count(sid) cnt
from   v$session_wait  a
where  
    STATE = 'WAITING'  ---- este estado indica que a sessão esta em wait
group by  event
/


---------------Show real time session wait details -------------

col sid    format    9999  heading "SID"
col event  format     a35  heading "Wait Event" trunc
col state  format     a15  heading "Wait State" trunc
col siw    format 999999999  heading "Waited So|Far (sec)"
col wt     format 999999999  heading "Time Waited|(sec)"
col seq#   format 9999999

def osm_prog="swsw.sql"
def osm_title="Real Time Session Wait Details"

-- start osmtitle

select sid,seq#,
       event,
       state,
       seconds_in_wait siw,
       wait_time wt
from   v$session_wait
-- order by event, sid
order by seconds_in_wait desc -- se a session estiver em wait no momneto da query a coluna seconds_in_wait será preenchida
/


------------------ Session Wait Enqueue Details --------------------------------

col sid   format    9999 heading "Sid"
col enq   format      a4 heading "Enq."
col edes  format     a30 heading "Enqueue Name"
col md    format     a10 heading "Lock Mode" trunc
col p2    format 9999999 heading "ID 1"
col p3    format 9999999 heading "ID 2"

select sid,
       chr(bitand(p1,-16777216)/16777215)||
       chr(bitand(p1, 16711680)/65535) enq,
       decode(
         chr(bitand(p1,-16777216)/16777215)||chr(bitand(p1, 16711680)/65535),
                'TX','Transaction (RBS)',
                'TM','DML Transaction',
                'TS','Tablespace and Temp Seg',
                'TT','Temporary Table',
                'ST','Space Mgt (e.g., uet$, fet$)',
                'UL','User Defined',
         chr(bitand(p1,-16777216)/16777215)||chr(bitand(p1, 16711680)/65535))
         edes,
       decode(bitand(p1,65535),1,'Null',2,'Sub-Share',3,'Sub-Exlusive',
         4,'Share',5,'Share/Sub-Exclusive',6,'Exclusive','Other') md,
       p2,
       p3
from   v$session_wait
where  event = 'enqueue'
/

-------------------------- Session Wait Enqueue Details by COUNT --------------

col sid   format    9999 heading "Sid"
col enq   format      a4 heading "Enq."
col edes  format     a30 heading "Enqueue Name"
col md    format     a10 heading "Lock Mode" trunc
col p2    format 9999999 heading "ID 1"
col p3    format 9999999 heading "ID 2"
col cnt   format    9990 heading "Count"

select 
       chr(bitand(p1,-16777216)/16777215)||
       chr(bitand(p1, 16711680)/65535) enq,
       decode(
         chr(bitand(p1,-16777216)/16777215)||chr(bitand(p1, 16711680)/65535),
                'TX','Transaction (RBS)',
                'TM','DML Transaction',
                'TS','Tablespace and Temp Seg',
                'TT','Temporary Table',
                'ST','Space Mgt (e.g., uet$, fet$)',
                'UL','User Defined',
         chr(bitand(p1,-16777216)/16777215)||chr(bitand(p1, 16711680)/65535))
         edes,
       decode(bitand(p1,65535),1,'Null',2,'Sub-Share',3,'Sub-Exlusive',
         4,'Share',5,'Share/Sub-Exclusive',6,'Exclusive','Other') md,
       p2,
       p3,
       count(*) cnt
from   v$session_wait
where  event = 'enqueue'
group by p1, p2, p3
/

-------------------------------------


col event form a15
col sid form 999
col user form a10
col PGM form a10
col LATCH form a20

select event,w.sid "SID", s.username "USER", l.name "LATCH", s.program "PGM", 
       w.p1,w.p2,w.p3,l.gets,l.misses,l.sleeps,l.IMMEDIATE_GETS,l.IMMEDIATE_MISSES
from  v$latch l, v$session s, v$session_wait w
where event like '%latch%'
  and s.sid = w.sid
  and l.latch# = w.p2
  and l.sleeps > 0
/


-----------------------------------

col sid format 990
col program format a15 word_wrap
col latch format a10 word_wrap
col process format a8 word_wrap heading "Clnt|PID"
col ospid format 9999990 heading "Srvr|PID"
col sql_text format a30 word_wrap
col instance new_value V_INSTANCE noprint
select	lower(replace(t.instance,chr(0),'')) instance
from	sys.v_$thread        t,
	sys.v_$parameter     p
where	p.name = 'thread'
and	t.thread# = to_number(decode(p.value,'0','1',p.value));

select	w.sid,
	c.name || ' (child #' || c.child# || ')' latch,
	s.program,
	s.machine || ', ' || s.process process,
	p.spid ospid,
	a.sql_text
from	v$session_wait		w,
	v$latch_children	c,
	v$session		s,
	v$process		p,
	v$sqlarea		a
where	w.event = 'latch free'
and	c.addr = w.p1raw
and	s.sid = w.sid
and	p.addr = s.paddr
and	a.address (+) = s.sql_address
/


rem =========================================================================
rem
rem *********** antes de usar execute o script inswait8 (cudidado)
rem # Current waits (slow !)
rem
rem -------------------------------------------------------------------------
rem
--spool c:\seswion_wait
select substr('Table ' || u.name || '.' || o.name || 
            decode(x.class, 1, '/Data blk', 4, '/Seg hdr', '')
             || ' (wait time  =  ' || to_char(w.wait_time) || ') : '
             || a.sql_text, 1, 200)
from v$session_wait w, 
     v$session s, 
     sys.uet$ ue, 
     sys.wait_info$ x, 
     sys.tab$ t, 
     sys.obj$ o, 
     sys.user$ u, 
     v$sqlarea a
where s.sid = w.sid
  and s.username is not null
  and s.audsid != userenv('SESSIONID')
  and w.event = 'buffer busy waits'
  and w.p1 = ue.file#
  and w.p2 between ue.block# and ue.block#+ue.length-1
  and w.p1 = x.dbafil
  and w.p2 = x.dbablk
  and t.file# = ue.segfile#
  and t.block# = ue.segblock#
  and t.obj# = o.obj#
  and o.owner# = u.user#
  and s.sql_address = a.address
  and s.sql_hash_value = a.hash_value
union
select substr('Index ' || u.name || '.' || o.name || ' on ' || ot.name || 
              decode(x.class, 1, '/Data blk', 4, '/Seg hdr', '')
           || ' (wait time  =  ' || to_char(w.wait_time) || ') : '
           || a.sql_text, 1, 200)
from v$session_wait w, 
     v$session s, 
     sys.uet$ ue, 
     sys.wait_info$ x, 
     sys.ind$ i, 
     sys.obj$ o, 
     sys.user$ u, 
     sys.obj$ ot, 
     v$sqlarea a
where s.sid = w.sid
  and s.username is not null
  and s.audsid != userenv('SESSIONID')
  and w.event = 'buffer busy waits'
  and w.p1 = ue.file#
  and w.p2 between ue.block# and ue.block#+ue.length-1
  and w.p1 = x.dbafil
  and w.p2 = x.dbablk
  and i.file# = ue.segfile#
  and i.block# = ue.segblock#
  and i.obj# = o.obj#
  and o.owner# = u.user#
  and i.bo# = ot.obj#
  and s.sql_address = a.address
  and s.sql_hash_value = a.hash_value
 union
select substr('RBS ' || u.name || ' (wait time  =  '
              || to_char(w.wait_time) || ') : '
              || a.sql_text, 1, 200)
from v$session_wait w, 
     v$session s, 
     sys.uet$ ue, 
     sys.undo$ u, 
     v$sqlarea a
where s.sid = w.sid
  and s.username is not null
  and s.audsid != userenv('SESSIONID')
  and w.event = 'buffer busy waits'
  and w.p1 = ue.file#
  and w.p2 between ue.block# and ue.block#+ue.length-1
  and u.file# = ue.segfile#
  and u.block# = ue.segblock#
  and s.sql_address = a.address
  and s.sql_hash_value = a.hash_value
union
select  substr(w.event || ' (wait time  =  ' || to_char(w.wait_time) || ') : '
       || a.sql_text, 1, 200)
from v$session_wait w, 
     v$session s, 
     v$sqlarea a
where s.sid = w.sid
  and s.username is not null
  and s.audsid != userenv('SESSIONID')
  and w.event in('enqueue', 'free buffer waits', 
                 'db file scattered read', 'db file parallel write','direct path write','direct path read')
  and s.sql_address = a.address
  and s.sql_hash_value = a.hash_value
union
select substr('latch free (wait time  =  ' || to_char(w.wait_time) || ') : '
               || l.name, 1, 200)
from v$session_wait w, 
     v$session s, 
     v$latch l
where s.sid = w.sid
  and s.username is not null
  and s.audsid != userenv('SESSIONID')
  and w.event = 'latch free'
  and w.p2 = l.latch#
/


--------------------------------------------------


set echo off feedback off timing off pause off
set pages 100 lines 500 trimspool on trimout on space 1 recsep each

col sid format 990
col program format a20 word_wrap
col event format a30 word_wrap
col ospid format 9999990 heading "Srvr|PID"
col name format a30 word_wrap heading "OBJECT NAME"
col sql_text format a30 word_wrap
col instance new_value V_INSTANCE noprint


select /*+ rule */
	w.sid,
	w.event,
	s.program,
	p.spid ospid,
	e.owner || '.' || e.segment_name || ' (' || e.segment_type || ')' name,
	a.sql_text
from	sys.v_$sqlarea		a,
	sys.dba_extents		e,
	sys.v_$process		p,
	sys.v_$session		s,
	sys.v_$session_wait	w
where	
  w.event in ('write complete waits','buffer busy waits','free buffer waits','db file sequential read','direct path read',
'direct path write')
and	
s.sid = w.sid
and	p.addr = s.paddr
and	e.file_id = to_number(w.p1)
and	to_number(w.p2) between e.block_id and (e.block_id + (e.blocks - 1))
and	a.address (+) = s.sql_address
/

spool off

